# 마이크로서비스 아키텍처

> 서비스 규모는 점점 커져 가고 새롭게 추가되는 기능들은 기존 기능과 서로 얽혀서 점점 복잡해진다. 이를 해결하기 위해 애플리케이션 코드를 `리팩터링`하거나 시스템 구조를 변경해서 시스템 복잡도를 낮추어야한다.
>

- 아키텍트 (Architect) : 시스템 컴포넌트를 나누고 합치는 디자인을 하는 사람
- 아키텍처 (Architecture) : 컴포넌트와 컴포넌트의 관계를 정리한 것
- 모놀리식 (Monolithic) : 서비스 기능을 하나의 API 컴포넌트에서 처리하는 구조
- 분산 처리 (Distributed) : 기능을 분리해 두 개 이상의 API 컴포넌트에서 처리하는 구조

마이크로 서비스 아키텍처는 분산 시스템 아키텍처 중 하나다. 특히 마이크로서비스 아키텍처는 앞서 `다량의 요청`을 처리하고 애플리케이션 복잡도를 낮추어 주는 여러 장점이 있다. 실제로 구현하기 어렵고, 여러 시스템이 유기적으로 얽혀 있어 운영이 쉽지 않은 `복잡한 아키텍처`다.

- 작은 단위로 나누어 분리하고, 각각의 `컴포넌트`는 `독립`된 시스템 형태로 개발하고 운영한다.
- 독립된 마이크로 서비스들은 전체 서비스와 `분리해 개발`할 수 있으므로 서비스 변화에 자유로워 `민첩한 대응`이 가능하다.

## 모놀리식 아키텍처

> 하나의 시스템이 서비스 전체 기능을 처리하도록 설계한 것으로, 작은 단위로 기능을 분리해 처리하는 것과 반대되는 개념
>

**인프라 관점**

`마이크로 서비스 아키텍처`는 컴포넌트 마다 서버 용량이 다양하고 여러 언어로 구성된 다양한 애플리케이션이 있다.

`모노리식 아키텍처`는 하나의 애플리케이션 만 있다.

그러므로 아키텍처에 따라 소프트웨어 설계 방법, 서버와 네트워크 설계 방법, 소스 배포 방법 등이 완전히 다르다.

### 모놀리식 아키텍처 장점

![스크린샷 2024-03-04 오후 5 11 02](https://github.com/oslob99/spring-msa/assets/126937987/ce0620d3-bb08-4b5f-a806-a041d74ab9e8)

- 하나의 `WAS (Web Application Server)`에서 모든 기능을 처리하도록 구성
- `RDB 같은 데이터 저장소`를 사용해 구조가 매우 간단하다.
- 애플리케이션도 하나라, `코드베이스`도 하나면 충분해 개발자는 클래스 단위로 기능 개발하고, 데이터는 객체들 사이에서만 전달되어 서비스의 기능들은 클래스들의 `유기적인 조합`으로 이루어진다.
- 데이터 저장소가 하나이므로 `RDB의 트랜잭션 (Transaction) 기능`을 쉽게 사용할 수 있어 `트랜잭션의 커밋,롤백`을 사용해, 데이터를 여러 테이블에 `영속할 때 (Persistence) 일관성`을 유지할 수 있다.

→ 간단하게 개발할 수 있고 쉽게 운영 가능하고, 간단한 구조이므로 장애에도 견고하다.

### 모놀리식 아키텍처의 단점

![스크린샷 2024-03-04 오후 5 11 02](https://github.com/oslob99/spring-msa/assets/126937987/ce0620d3-bb08-4b5f-a806-a041d74ab9e8)

- 애플리케이션 서버는 정적 파일뿐만 아니알 서비스 기능까지 웹 서비스에 필요한 모든 기능을 제공
- `동적 HTML`을 제공하기 위해 `JSP 혹은 Thymeleaf` 같은 `템플릿 엔진`을 사용하게 되어야해서 코드베이스에 JS 파일과 CSS 파일이 포함되어야 한다.
- 결국, 코드베이스에는 클라이언트 기능과 서버 기능이 뒤섞인 채 개발해야 한다.

→ 소스 코드는 증가하고 복잡도는 증가해 빌드하는 시간도 늘고, 복잡하게 얽힌 코드를 수정하는 일도 점차 힘들어져 개발 속도나 생산성도 점차 낮아진다.

### 수평적 확장: 스케일 아웃

점차 늘어나는 `사용자의 요청`들을 감당하기 위해 시스템을 확장해야 하고, 시스템의 안정성을 위해서도 `고가용성 (High Avaliability, HA)`을 확보해야 한다.

![스크린샷 2024-03-04 오후 5 20 04](https://github.com/oslob99/spring-msa/assets/126937987/8eb7d3a9-a783-4c70-b599-ba3b73a175d9)

L4, L7등 하드웨어나 `HAProxy` 등 소프트웨어 `로드 밸런서`를 사용해 `클라이언트 요청`들을 연결된 `WAS`에 재분배한다. → 분산 부하

`로드 밸런서`에 연결된 WAS 인스턴스 숫자를 늘려서 `전체 처리량`을 늘리는 것을 스케일 아웃(`Scale-Out`) → 시스템 안정성을 높이고 `처리량을 증가`시킬 수 있다.

`로드 밸런서`도 성능 한계가 있으며, 성능 한계를 넘어서는 상황에서 어떻게 처리할지 고민해야한다.

### 그래서

**모놀리식 아키텍처 장단점**

- 소규모 개발팀으로 간단하고 작은 기능을 제공하는 서비스라면 `효율적`
- 빠른 시간안에 개발할 수 있고, 운영과 유지 보수가 편하다
- 확장에 한계가 있으며 `비효율적`이다.
- 기능이 많아질 수록 개발 속도나 생산성이 낮아지므로 서비스 고도화에 한계가 생김

**마이크로 서비스 아키텍처로 전환을 고려해볼 상황**

- 클라이언트 요청이 점점 많아지는데 `로드 밸런서`로 확장해도 한계가 있을 때
- 데이터베이스 성능을 높여도 더 이상 성능 개선의 여지가 없을 때
- 기능 확장 요구가 많지만 현재 시스템 구조로 불가능할 때
- 소스코드가 너무 복잡해 `리팩토링`이 필요할 때
- 기능 중 하나라도 변경되면 전체 `QA`를 해야할 때