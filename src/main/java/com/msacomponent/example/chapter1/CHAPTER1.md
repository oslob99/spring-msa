# 스프링 부트로 개발하는 MSA 컴포넌트

## 1.1 모놀리식 아키텍처 소개

> 서비스 규모는 점점 커져 가고 새롭게 추가되는 기능들은 기존 기능과 서로 얽혀서 점점 복잡해진다. 이를 해결하기 위해 애플리케이션 코드를 `리팩터링`하거나 시스템 구조를 변경해서 시스템 복잡도를 낮추어야한다.
>

- 아키텍트 (Architect) : 시스템 컴포넌트를 나누고 합치는 디자인을 하는 사람
- 아키텍처 (Architecture) : 컴포넌트와 컴포넌트의 관계를 정리한 것
- 모놀리식 (Monolithic) : 서비스 기능을 하나의 API 컴포넌트에서 처리하는 구조
- 분산 처리 (Distributed) : 기능을 분리해 두 개 이상의 API 컴포넌트에서 처리하는 구조

마이크로 서비스 아키텍처는 분산 시스템 아키텍처 중 하나다. 특히 마이크로서비스 아키텍처는 앞서 `다량의 요청`을 처리하고 애플리케이션 복잡도를 낮추어 주는 여러 장점이 있다. 실제로 구현하기 어렵고, 여러 시스템이 유기적으로 얽혀 있어 운영이 쉽지 않은 `복잡한 아키텍처`다.

- 작은 단위로 나누어 분리하고, 각각의 `컴포넌트`는 `독립`된 시스템 형태로 개발하고 운영한다.
- 독립된 마이크로 서비스들은 전체 서비스와 `분리해 개발`할 수 있으므로 서비스 변화에 자유로워 `민첩한 대응`이 가능하다.

## 모놀리식 아키텍처

> 하나의 시스템이 서비스 전체 기능을 처리하도록 설계한 것으로, 작은 단위로 기능을 분리해 처리하는 것과 반대되는 개념
>

**인프라 관점**

`마이크로 서비스 아키텍처`는 컴포넌트 마다 서버 용량이 다양하고 여러 언어로 구성된 다양한 애플리케이션이 있다.

`모노리식 아키텍처`는 하나의 애플리케이션 만 있다.

그러므로 아키텍처에 따라 소프트웨어 설계 방법, 서버와 네트워크 설계 방법, 소스 배포 방법 등이 완전히 다르다.

### 모놀리식 아키텍처 장점

![장점](https://github.com/oslob99/spring-msa/assets/126937987/f015e1a2-5fc2-4fda-8c76-bf3cff032580)

- 하나의 `WAS (Web Application Server)`에서 모든 기능을 처리하도록 구성
- `RDB 같은 데이터 저장소`를 사용해 구조가 매우 간단하다.
- 애플리케이션도 하나라, `코드베이스`도 하나면 충분해 개발자는 클래스 단위로 기능 개발하고, 데이터는 객체들 사이에서만 전달되어 서비스의 기능들은 클래스들의 `유기적인 조합`으로 이루어진다.
- 데이터 저장소가 하나이므로 `RDB의 트랜잭션 (Transaction) 기능`을 쉽게 사용할 수 있어 `트랜잭션의 커밋,롤백`을 사용해, 데이터를 여러 테이블에 `영속할 때 (Persistence) 일관성`을 유지할 수 있다.

→ 간단하게 개발할 수 있고 쉽게 운영 가능하고, 간단한 구조이므로 장애에도 견고하다.

### 모놀리식 아키텍처의 단점

![단점](https://github.com/oslob99/spring-msa/assets/126937987/f015e1a2-5fc2-4fda-8c76-bf3cff032580)

- 애플리케이션 서버는 정적 파일뿐만 아니알 서비스 기능까지 웹 서비스에 필요한 모든 기능을 제공
- `동적 HTML`을 제공하기 위해 `JSP 혹은 Thymeleaf` 같은 `템플릿 엔진`을 사용하게 되어야해서 코드베이스에 JS 파일과 CSS 파일이 포함되어야 한다.
- 결국, 코드베이스에는 클라이언트 기능과 서버 기능이 뒤섞인 채 개발해야 한다.

→ 소스 코드는 증가하고 복잡도는 증가해 빌드하는 시간도 늘고, 복잡하게 얽힌 코드를 수정하는 일도 점차 힘들어져 개발 속도나 생산성도 점차 낮아진다.

### 수평적 확장: 스케일 아웃

점차 늘어나는 `사용자의 요청`들을 감당하기 위해 시스템을 확장해야 하고, 시스템의 안정성을 위해서도 `고가용성 (High Avaliability, HA)`을 확보해야 한다.

![확장](https://github.com/oslob99/spring-msa/assets/126937987/73ccfb6e-5005-4331-a784-1a6832454299)

L4, L7등 하드웨어나 `HAProxy` 등 소프트웨어 `로드 밸런서`를 사용해 `클라이언트 요청`들을 연결된 `WAS`에 재분배한다. → 분산 부하

`로드 밸런서`에 연결된 WAS 인스턴스 숫자를 늘려서 `전체 처리량`을 늘리는 것을 스케일 아웃(`Scale-Out`) → 시스템 안정성을 높이고 `처리량을 증가`시킬 수 있다.

`로드 밸런서`도 성능 한계가 있으며, 성능 한계를 넘어서는 상황에서 어떻게 처리할지 고민해야한다.

### 그래서

**모놀리식 아키텍처 장단점**

- 소규모 개발팀으로 간단하고 작은 기능을 제공하는 서비스라면 `효율적`
- 빠른 시간안에 개발할 수 있고, 운영과 유지 보수가 편하다
- 확장에 한계가 있으며 `비효율적`이다.
- 기능이 많아질 수록 개발 속도나 생산성이 낮아지므로 서비스 고도화에 한계가 생김

**마이크로 서비스 아키텍처로 전환을 고려해볼 상황**

- 클라이언트 요청이 점점 많아지는데 `로드 밸런서`로 확장해도 한계가 있을 때
- 데이터베이스 성능을 높여도 더 이상 성능 개선의 여지가 없을 때
- 기능 확장 요구가 많지만 현재 시스템 구조로 불가능할 때
- 소스코드가 너무 복잡해 `리팩토링`이 필요할 때
- 기능 중 하나라도 변경되면 전체 `QA`를 해야할 때

## 1.2 마이크로서비스 아키텍처 소개

> 기능 위주로 나뉜 여러 애플리케이션이 있고, 각각 독립된 데이터 저장소를 사용한다.
기능으로 분리된 애플리케이션들은 미리 정의된 인터페이스를 통해 서로 유기적으로 동작해 웹이나 APP 클라이언트에 일관된 형태의 API 로 제공된다.
>

![아키텍처](https://github.com/oslob99/spring-msa/assets/126937987/d6c0155f-d4cf-4bb8-a2b1-572afaea8956)

**마이크로서비스 아키텍처의 대표적인 특징**

- 대규모 시스템
- 분산 처리 시스템
- 컴포넌트들의 집합
- 서비스 확장

→ 대규모 시스템을 설계할 때 서비스 기능 단위로 묶어 시스템 기능을 구현한 서비스 지향 아키텍처 (Service Oriented Architecture, SOA) 공통점이 많다

**마이크로서비스 아키텍처 설계 전 주의 사항**

마이크로 서비스들은 각각 `다른 마이크로서비스`들과 독립적으로 구성되어야 한다. → 느슨한 결합 (`loosely coupled`)

- 서로 의존하게 되면 `복잡도`는 더욱 증가해 서비스 하나에서 장애가 발생하면 연쇄적으로 장애가 발생하는 단일 장애 지점이 큰 문제다.
- 각 마이크로 서비스들은 서로 분리 되어있어 네트워크를 통해 서로 기능을 통합해야 한다. → 기능이 각각 분리되면서 서로 결합되어야 함.

**마이크로서비스 컴포넌트 기능 연동 중 주의 사항**

마이크로서비스 컴포넌트 기능을 연동할 때 API 를 통해 서로 데이터를 주고받는다. → `네트워크 프로토콜`이 성능 저하의 원인이 될 수 있다.

- 객체를 바이트 형태로 변경 → `직렬화(serialize)`
- 바이트 형태를  객체로 변환 과정 → `역직렬화(deserialize)`

가벼운 프로토콜을 선정해 통신하지 않는다면 `직력화/역직렬화 과정`에서 CPU 와 메모리같은 시스템 리소스를 많이 사용해 시스템의 전반적인 성능 저하가 발생

→ 보통 Json 형식의 메세지를 주고 받으며, `HTTP기반의 REST-API`를 사용

→ 이외에도 `gRPC(Google Remote Procedure Call)` 이나 비동기 처리를 위한 `AMQP 프로토콜`을 사용하는 메시지 큐 시스템 기반인 RabbitMQ, 메시징 스트리밍 시스템 Kafka

→ 메시징 큐 시스템 기반의 데이터 교환은 REST-API 기반의 통신보다는 높은 신뢰성을 제공하지만 의존성이 생겨 단일 장애 지점이 되기도 한다.

**마이크로서비스 아키텍처 특징**

- 잘 `분리된(fine grained)`  마이크로서비스로 인한 `탈중앙화`
- 대규모 시스템을 위한 아키텍처
- 느슨한 결합
- 서비스 지향 아키텍처

### 마이크로서비스 아키텍처 장점

**독립성**

하나의 비즈니스 기능을 담당해 `다른 마이크로서비`스와 간섭이 최소화된다.
마이크로서비스는 독립된 데이터 저장소를 갖고 있어 `데이터 간섭`에도 자유롭다.

**대용량 데이터 저장 후 처리하는 데 자유롭다**

서비스 규모가 커지면 수많은 데이터를 저장해야 하는데, `RDB`는 스케일 아웃이 쉽지 않아 `데이터 샤딩`을 통해 데이터를 분산해서 저장하기도 한다.

**하지만 RDB**

데이터가 분산 저장되면 `RDB`를 운영하기 쉽지 않아 진입 장벽이 높다
`RDB`는 `선형 확장`이 쉽지 않다.

`MySQL`은 데이터 복제 기능을 이용해 복제 서버를 구성할 수 있어 데이터베이스 클러스터로 관리할 수 있다.

→ 복제 서버는 읽기 `성능만 증가`할 뿐 생성,수정,삭제 성능이 형적으로 증가하지 않는다.

**하지만 NoSQL**

RDB 보다 확장성, 성능에서 뛰어난 `NoSQL`도 여러 단점 존재

- 무한의 선형적 성능 향상 기대는 어렵다
- 데이터를 알고리즘에 의해 `여러 노드`에 분산해 저장한다.
- 데이터 저장소를 추가로 확장한다면 `여러 노드`에 저장된 데이터들을 다시 배치해야 한다 : `리밸런싱(rebalancing)`

→ 작업 시간 동안 `각 노드의 CPU` 나 `디스크 IO 부하`가 높아져 시스템 전반에 부하로 인한 장애가 발생하거나 성능이 떨어질 수 있다.

마이크로서비스는 `독립된 데이터 저장소`를 갖고 있어 대용량 데이터를 마이크로서비스 마다 나누어 저장 가능

**시스템 장애에 견고**

마이크로서비스는 서로 느슨하게 결합되어 있고, 각각 독립되어 있어 서로 간에 미치는 영향이 적다.

→ 하나의 마이크로서비스가 장애나 버그가 발생해도 다른 마이크로서비스는 서비스된다.

**서비스 배포 주가 빠름**

|  | 모놀리식 아키텍처 | 마이크로서비스 아키텍처 |
| --- | --- | --- |
| 배포 주기 | 모든 기능이 하나의 코드베이스에서 개발되어 배포 일정을 정하고, 모든 기능을 한 번에 배포한다. | 모든 기능이 분리되 있어 필요한 기능만 먼저 배포한다. |
| 버그 발생 | 서비스 전체를 롤백하거나 모든 시스템을 배포한다. | 특정 마이크로서비스만 수정해서 배포하면 된다. |

<img width="749" alt="image" src="https://github.com/oslob99/spring-msa/assets/126937987/103dd270-9285-4494-9c6d-3370c253e8bf">

**확장성이 좋다**

`필요한 마이크로서비스`만 확장할 수 도 있어 효율적으로 시스템 자원을 사용할 수 있고, 클라우드 시스템과 결합하면 `시스템 컴포턴트`들을 동적으로 확장할 수 있다.

**사용자 반응에 민첩하게 대응 가능**

- 새로운 서비스를 `마이크로소비스`로 분리해 설계하고 시스템에 포함하면 사용자 반응에 따라 시스템을 `고도화`하거나 빠르게 시스템에서 제외할 수 있다.
- 각각의 마이크로서비스는 `독립`되어 있어 필요한 서비스에 대해서 수정 후 배포하면 대응 가능하다.

### 마이크로서비스 아키텍처 단점

> 마이크로서비스 아키텍처가 `만능`은 아니다.
>

**개발하기 어려운 아키텍처**

다른 시스템이 `네트워크상 분산`되어 있어 프로세스가 다른 마이크로서비스를 개발할 때는 여러 상황을 고려해 분리된 데이터, 네트워크를 통한 `데이터 통합`을 해야한다.

- 각 마이크로서비스들은 독립적인 데이터 저장소를 갖고 있어 `RDB`의 최대 장점인 `DB 트랜잭션`(`Transaction`)을 사용할 수 없다. → `데이터 정합성`이 맞지 않거나 중복된 데이터가 발생한다.

`데이터 통합`하기 위해서는 표준화된 인터페이스로 데이터를 처리해야 한다.

- 네트워크는 신뢰할 수 없고, `커넥션`을 맺는 비용이 비싸다는 점
- 네트워크는 언제든지 장애가 발생할 수 있고, `패킷`은 언제든 누락될 수 있는 점
- 요청한 응답을 받지 못하는 상황과 `네트워크 지연`이 발생할 수도 있다는 점
- 데이터를 `직렬화/역직렬화` 하는데 비용 발생

→ 지연 시간은 일정하지 않고 상황에 따라 변해 `커넥션 풀(Connection Pool)`을 이용해 `API 호출`한다.

개발자는 여러 장애 상황을 대비하는 `풀백(fullback) 기능`을 고려해야 한다.

- 풀백은 네트워크가 `정상적이지 않`거나 다른 마이크로서비스가 운영이 불가능 상태일 때를 대비하는 기능

**운영하기 매우 어려운 아키텍처**

<img width="536" alt="스크린샷 2024-03-10 오후 5 24 36" src="https://github.com/oslob99/spring-msa/assets/126937987/eab8aa3b-6ecb-4e9d-b214-d4dc601f4296">

> 위 그림과 같이 하나의 기능을 클라이언트에 제공하려면 선으로 연결된 여러 마이크로서비스의 `통합된 데이터`가 필요하다
>

각 마이크로서비스가 독립적으로 분리되어 있어 하나의 프로세스를 거치는데 `수 많은 서비스의 응답`을 받아야 하며, 모든 과정이 요청에 `이상 없이 처리`되어야 하기에 마이크로서비스가 통합되어야 한다.

- 데이터 분산으로 `분산 트랜잭션`을 사용하지 않는다면 데이터 일관성을 유지하기 어렵다.

**설계하기 어려운 아키텍처**

> 잘 설계된 마이크로서비스 아키텍처는 보다 쉽게 유지 보수할 수 있고, 많은 요청을 처리할 수 있는 장점으로 장점들을 극대화할 수 있다.
>

마이크로서비스의 `관계가 명확`하지 않고 `잘못된 방향`으로 설계된다면 유지 보수 시간 오랜 시간이 소모되고 `데이터 파편화 현상`으로 `일관성 있는 데이터`를 유지하기 어렵게 되고 과도한 네트워크 통신이 발생해 `성능이 저하`될 수 있다.

**서비스 운영에 여러가지 자동화된 시스템 필요**

마이크로서비스 아키텍처를 도입하는 가장 큰 이유로 빠른 서비스 개발과 운영, 대규모 서비스를 처리하기 위해서 `CI/CD 시스템`이 필요하다.

**마이크로서비스를 운영,개발하는 개발자의 기술력이 좋아야한다.**

하나의 마이크로서비스 개발 속도는 개발자 숫자와 비례해 선형적으로 증가하지 않는다.

마이크로서비스가 운영과 개발이 `어려운 서비스`이기에 기술 성숙도가 낮은 팀은 `부적합`하며, 오히려 개발 속도와 서비스 안전성 면에서 `역효과 발생`

## 1.3 마이크로서비스 아키텍처 설계

> 잘 분리된 마이크로서비스는 각 개념이 서로 겹치지 않고 `독립적으로 서비스` 되는 것
>

잘 분리된 마이크로서비스를 설계하는 과정에서 `겪을 수 있는 혼란`

- 전체 서비스 관점에서 어느정도 크기로 서비스를 분리해야 할까?
- 너무 작게 혹은 크게 분리하는 것은 아닐까?
- 분리된 마이크로서비스간에 `표준 인터페이스 통신`은 어떻게 할까?

마이크로서비스 아키텍처를 설계할 때 정해진 법도나 왕도는 없으므로 서비스 요건이 추가되거나 비즈니스 상황이 바뀌면 언제든지 설계는 변경이 가능하다.

### 서비스 세분화 원칙

> 비즈니스, 성능, 메시지 크기, 트랜잭션으로 구성된 요소로 서비스를 나누도록 제안한다.
>

**비즈니스 기능**

하나의 서비스가 여러 비즈니스 동작을 제공하면 `서비스 복잡도`가 높아지고 유지 보수가 어려워진다.

**성능**

마이크로서비스는 독립적으로 분리되어 있어 `네트워크와 프로토콜`을 써서 서로의 데이터나 기능을 사용한다.

→ 특정 마이크로서비스의 `성능이 떨`어지면 서비스 전체의 안전성과 성능에 문제가 발생해 해당 서비스를 `나누는 것을 고려`해야 한다.

**메시지 크기**

`API를 설계`하는 데 메시지 크기가 크다면 `직렬화/역직렬화`하는 데 성능 문제를 일으키므로 마이크로서비스를 나누는  것을 고려하자.

단, 비즈니스 기능이나 일관성을 유지하는 `트랜잭션에 문제`가 없다면 무시.

**트랜잭션**

`데이터 정합성`을 유지하는 `트랜잭션`으로 서비스를 나누는 것이 좋다.

→ 데이터 유실이나 정확한 데이터를 유지하는 데 도움이 되기 때문에